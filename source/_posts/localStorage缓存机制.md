---
title: ZT-localStorage缓存机制
date: 2017-01-22 09:26:17
tags: Javascript
---

首先，localStorage的确是可以做JS以及CSS缓存的，详情可以通过F12看<http://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&mid=2735610010&idx=1&sn=67e3f0833f1097a279d850e2098956ff&scene=0#wechat_redirect>

按道理说这个机制是非常诱人的，毕竟localStorage可存储体积大，并且用户一旦开启便不容易清除，所以从工程师的角度来看这个工具非常适合缓存一些并不经常需要维护更新的脚本和样式文件。

当然，假如要更新的话，就得好好设计一下更新机制，普通的资源请求，可以根据文件名+md5 http://res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/moon32ebc4.js或者在资源链接后面加上特定的后缀http://1.ss.faisys.com/js/comm/fai.min.js?v=201612051739做标识来判断是否需要更新资源。如果用localStorage做，则需要一套新的缓存更新机制。

微信的做法是每个文件都单独维护一个localStorage变量，来记录版本号，从而由后台来判断是否需要更新。

<!-- more -->

## 此方案的优点
对于传统的浏览器缓存（如COOKIE）, 用户主动触发的页面刷新行为（比如刷新按钮、右键刷新、F5等），会导致浏览器放弃本地缓存，使用协商缓存（304缓存），用了LS之后，可以完全避免这种情况，等效于无视用户主动刷新行为的本地强缓存。当LS+eval速度大于304协商速度时，LS方案具有统计上的正收益。


还有，缓存问题也绝不是一个页面的问题，网站很多页面之间会跳转访问，彼此之间也有共享的静态资源，基于url的缓存让跨页面之间缓存共享问题变得粗粒度。举个例子，有A、B两个页面，彼此有访问路径（比如百度首页和搜索结果页之间的访问），其中：
* A页面使用资源：a, b, c, d
* B页面使用资源：a, b, c, e, f

假设不考虑并发请求的优化，我们希望尽可能的打包，再假设A页面是主要入口，那么，最合理的方案可能就是a-b-c-d打包（设为[abcd]），e-f打包（设为[ef]），从而使得：
* A页面使用url：[abcd]
* B页面使用url：[abcd]+[ef]
* 由于用户大多首次访问A页面，然后会跳转到B页面，所以访问A页面会很快，再跳转到B页面可以从缓存中使用[abcd]包，再只需加载[ef]包即可。为了更大的缓存利用率，我们让B页面复用A页面的url缓存，但多了一个不需要的d资源这也是合理的。也就是说，基于url的缓存利用可能在有些情况下会资源的冗余加载。想想那些通过url直接访问B页面的用户来说，无缓存情况下，页面加载的是[abcd]+[ef]两个资源包，既有冗余，又是两个请求，这并不是最理想的加载策略（这个方案是倾向于优化A页面展现的，虽然B页面首次展现不理想，但B页面大部分pv是从A页面导入，网站总体性能是更好的）。

而使用combo服务+LS的情况就不同了，假设combo的url的形式是[a,b,c,...]，那么单独访问A、B页面的资源url就是：
* A页面使用url：[a,b,c,d]
* B页面使用url：[a,b,d,e,f]
用户由A页面进入网站，加载[a,b,c,d]这个url，然后LS缓存4个资源，再跳转到B页面，缓存控制框架可以知道本地缓存了哪些，然后只发起[e,f]这个请求。其效果基本等效于浏览器基于URL的缓存。而对于那些没有通过A页面直接访问B页面的用户来说，B页面加载的是[a,b,d,e,f]，也是不错的合并策略。LS在这个时候就发挥了那么一点点优势。

当然，这种优势还不够明显，最能展现LS优势的，其实是单页面应用。因为单页面应用需要完全有JS管理页面状态，并增量加载资源，用户也可能通过带有hash的url直接访问某个单页面中的虚拟页面，同一个页面会有很多种不同的资源请求组合，这个时候，唯有LS+combo才能很好的解决资源加载与缓存问题。对于这种情况，我有一个网站可以用于展示效果：

Scrat - webapp模块化开发体系<http://scrat.io/#!/index>


## 方案存在的问题
首先，对SEO是不友好的。要进行SEO，必须直接输出完整HTML，因此必须让样式在头部以link标签加载。如果先输出HTML，后用js从本地缓存读取样式再插入，会出现严重的阻塞和闪烁问题，相信正常人是不会这么干的。

兼容性不太好，不支持LS的浏览器比例仍然很大。

在未来，HTTP2时代的到来应该会完美绝杀这种黑科技，因此，工程化的具体实施方法必然要与时俱进，不过工程化的方法论不会过时，无论在哪个时代，我们都应该全面、科学的分析工程问题，结合当前的浏览器环境和技术手段来做方案，保持网站的性能。

其次，引入localStorage中的缓存文件不像<script>标签插入JS那样可以自执行，因此需要一些技巧，常见的方法是写eval()函数，把所有的代码都执行出来，但是这有一个问题，就是不便于压缩。因此也可以用另一个方法：

```javascript
var script = document.createElement('script');
var code = '!function(){' + getCodeFromLocalStorage() + '\n}();';
script.appendChild(document.createTextNode(code));
document.head.appendChild(script);
```
容易出现安全问题，一旦有xss漏洞就会被人利用，将恶意代码注入到LS中导致即便修复了xss恶意代码也存在的问题。所以我们现在采用的策略是每次部署新版本就会清除全部缓存。这会导致缓存利用率的下降，不过至少还有部分浏览器缓存在呢，算是一个折中处理。






